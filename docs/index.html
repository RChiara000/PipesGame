<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, viewport-fit=cover" />
<style>
  :root { --bg:#0b1020; --panel:#111831; --accent:#3ad0ff; --good:#28d17c; --text:#e8eefb; --sink:#6be3a3; --vh:1vh; }

  * { box-sizing:border-box; }
  html, body {
    margin:0;
    height:100%;
    background:var(--bg);
    color:var(--text);
    font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial;
  }

  /* Crucial: make the app a column flex so main can grow */
  #app {
    display:flex;
    flex-direction:column;
    min-height:calc(var(--vh) * 100);   /* iOS-safe fallback */
  }
  /* Prefer modern dvh when available */
  @supports (height: 100dvh) {
    #app { min-height:100dvh; }
  }

  header {
    padding:6px 10px;
    background:linear-gradient(180deg,#0e1530,#0b1020);
    border-bottom:1px solid #1d2547;
    display:flex; gap:8px; align-items:center;
  }
  header h1 { font-size:14px; margin:0; color:var(--accent); font-weight:700; }
  .controls { display:flex; gap:6px; align-items:center; flex-wrap:wrap; }
  button { background:#1a2346; border:1px solid #2a3570; color:#e8eefb; padding:6px 10px; border-radius:10px; font-weight:600; cursor:pointer; }
  button:hover { background:#243062; }
  #flowRate { width:110px; }
  #hud { display:flex; gap:12px; align-items:center; margin-left:auto; font-size:13px; }
  #sinkStatus { padding:2px 8px; border:1px solid #2a3570; border-radius:999px; }

  /* Main must flex to fill the rest */
  main { flex:1; min-height:0; display:flex; }
  /* Stage wrapper must grow */
  #stageWrap { position:relative; flex:1; min-height:0; overflow:hidden; }

  canvas {
    width:100%; height:100%; display:block;
    background:radial-gradient(1200px 1200px at 80% -10%, #17234a 0%, #0b1020 55%);
    touch-action: none;
  }

  /* Overlay */
  .overlay { position:absolute; inset:0; display:flex; align-items:center; justify-content:center; background:rgba(7,12,26,.6); }
  .overlay.hidden { display:none; }
  .overlay .panel { background:#0f1734; border:1px solid #26336b; border-radius:14px; padding:14px; min-width:280px; text-align:center; }
  .overlay .panel h3 { margin:0 0 8px; font-size:16px; color:#bcd3ff; }
  .overlay .panel p { margin:0 0 10px; font-size:13px; opacity:.9; }
  .overlay .actions { display:flex; gap:8px; justify-content:center; flex-wrap:wrap; }
  .pill { padding:8px 12px; border-radius:999px; border:1px solid #2a3570; background:#1a2346; color:#e8eefb; cursor:pointer; }
  .pill:hover { background:#243062; }
</style>
</head>
<body>
<div id="app">
  <header>
    <h1>ðŸ’§ Valves & Diamonds</h1>
    <div class="controls">
      <button id="startBtn">Start</button>
      <button id="pauseBtn">Pause</button>
      <button id="resetBtn">Reset</button>
      <button id="nextBtn">Next</button>
      <span>Flow <input type="range" id="flowRate" min="0.5" max="3" step="0.1" value="1.4"></span>
    </div>
    <div id="hud">
      <span>Level <strong id="levelNum">1</strong></span>
      <span>Diamonds <strong id="gemScore">0</strong>/<span id="gemTotal">0</span></span>
      <span id="sinkStatus">Sink: <strong id="sinkReached">No</strong></span>
    </div>
  </header>
  <main>
    <div id="stageWrap">
      <canvas id="stage" width="1200" height="800"></canvas>
      <div id="overlay" class="overlay hidden">
        <div class="panel">
          <h3>Flow Stopped</h3>
          <p><span id="finalScore">0</span>/<span id="finalTotal">0</span> diamonds collected</p>
          <p id="solutionSummary">Recommended network targets 0/0 diamonds.</p>
          <div class="actions">
            <button class="pill" id="overlayApplySol">Apply Solution</button>
            <button class="pill" id="overlayRestart">Restart</button>
            <button class="pill" id="overlayNext">Next Level</button>
          </div>
        </div>
      </div>
    </div>
  </main>
</div>

<script>
/* -------- iOS/Thunkable viewport height fix -------- */
function setVH() {
  // Some iOS webviews report vh including the title/URL bar; use innerHeight
  document.documentElement.style.setProperty('--vh', (window.innerHeight * 0.01) + 'px');
}
setVH();
window.addEventListener('resize', setVH);
window.addEventListener('orientationchange', setVH);

/* ============ Utility ============ */
const randInt = (a, b) => Math.floor(Math.random() * (b - a + 1)) + a;
const clamp = (v, a, b) => Math.max(a, Math.min(b, v));

/* ============ Level ============ */
class PipeLevel {
  constructor(cols, rows, spacing, pad=1) {
    this.cols = cols; this.rows = rows; this.spacing = spacing; this.pad = pad;
    this.nodes = [];
    this.edges = [];
    this.sourceId = null;
    this.sinkId = null;
    this.levelNo = 1;
    this.chuteGX = Math.floor(cols/2);
    this.solutionEdgeIds = new Set();
    this.solutionDiamonds = 0;
  }
  xy(gx, gy){ return { x:(gx+this.pad)*this.spacing, y:(gy+this.pad)*this.spacing }; }
  nodeId(gx, gy){ return `${gx},${gy}`; }

  gen(levelNo=1) {
    this.levelNo = levelNo;
    this.nodes=[]; this.edges=[]; this.sourceId=null; this.sinkId=null;
    this.solutionEdgeIds = new Set(); this.solutionDiamonds = 0;

    for (let gy=0; gy<this.rows; gy++){
      for (let gx=0; gx<this.cols; gx++){
        const {x,y} = this.xy(gx,gy);
        this.nodes.push({ id:this.nodeId(gx,gy), gx, gy, x, y, edges:[], isSource:false, isSink:false });
      }
    }
    const nodeById = new Map(this.nodes.map(n=>[n.id,n]));
    let eid=0;
    const addEdge = (aId,bId,valveOpen=true, markChute=false)=>{
      const A=nodeById.get(aId), B=nodeById.get(bId);
      if (!A||!B) return;
      if (this.edges.some(e=>(e.a===aId&&e.b===bId)||(e.a===bId&&e.b===aId))) return;
      const len=Math.hypot(B.x-A.x,B.y-A.y);
      const curve = Math.random()<0.2 ? {
        cx:(A.x+B.x)/2 + (Math.random()<0.5?1:-1)*randInt(0, this.spacing*0.16),
        cy:(A.y+B.y)/2 + (Math.random()<0.5?1:-1)*randInt(0, this.spacing*0.16)
      } : null;
      const mid={x:(A.x+B.x)/2, y:(A.y+B.y)/2};
      const diamondT = (Math.random()<0.5) ? (0.18 + Math.random()*0.16) : (0.66 + Math.random()*0.16);
      const e={ id:`e${eid++}`, a:aId, b:bId, curve,
        valveOpen, hasDiamond:false, diamondTaken:false, diamondT,
        filled:false, len, mid, t:0, dir:+1, isChute: markChute, brightness:0
      };
      this.edges.push(e);
      nodeById.get(aId).edges.push(e.id);
      nodeById.get(bId).edges.push(e.id);
    };

    // source & sink
    const sourceId=this.nodeId(this.chuteGX,0);
    const sinkId=this.nodeId(this.chuteGX,this.rows-1);
    nodeById.get(sourceId).isSource=true; this.sourceId=sourceId;
    nodeById.get(sinkId).isSink=true; this.sinkId=sinkId;

    // central chute
    for (let gy=0; gy<this.rows-1; gy++){
      addEdge(this.nodeId(this.chuteGX,gy), this.nodeId(this.chuteGX,gy+1), true, true);
    }

    // spanning tree
    const visited = new Set([sourceId]);
    const stack = [sourceId];
    const neighborOrder = ([gx,gy]) => {
      const ns = [[gx,gy+1],[gx-1,gy],[gx+1,gy],[gx,gy-1]]
        .filter(([x,y]) => x>=0 && x<this.cols && y>=0 && y<this.rows);
      for (let i=ns.length-1;i>0;i--){ const j=randInt(0,i); [ns[i],ns[j]]=[ns[j],ns[i]]; }
      ns.sort((a,b)=> (b[1]-a[1]));
      return ns;
    };
    while (stack.length){
      const cur = stack[stack.length-1];
      const {gx,gy} = nodeById.get(cur);
      const neigh = neighborOrder([gx,gy]).map(([nx,ny])=>this.nodeId(nx,ny)).filter(id=>!visited.has(id));
      if (neigh.length===0){ stack.pop(); continue; }
      const nxt = neigh[0];
      addEdge(cur, nxt, false, false);
      visited.add(nxt);
      stack.push(nxt);
    }

    // extra links
    const L = this.levelNo;
    const complexity = clamp(0.6 + 0.12*(L-1), 0.6, 1.4);
    const extraH = Math.floor(this.cols*this.rows*0.20 * complexity);
    const extraV = Math.floor(this.cols*this.rows*0.14 * complexity);
    for (let i=0;i<extraH;i++){
      const gy = randInt(0,this.rows-1);
      const gx = randInt(0,this.cols-2);
      addEdge(this.nodeId(gx,gy), this.nodeId(gx+1,gy), false, false);
    }
    for (let i=0;i<extraV;i++){
      const gx = randInt(0,this.cols-1);
      const gy = randInt(0,this.rows-2);
      addEdge(this.nodeId(gx,gy), this.nodeId(gx,gy+1), false, false);
    }

    // converge near bottom (open)
    for (let gy=this.rows-2; gy<this.rows; gy++){
      for (let side of [-1, +1]){
        const nx = this.chuteGX + side;
        if (nx>=0 && nx<this.cols){
          const a=this.nodeId(nx,gy), b=this.nodeId(this.chuteGX,gy);
          if (!this.edges.some(e=>(e.a===a&&e.b===b)||(e.a===b&&e.b===a))) {
            addEdge(a,b,true,false);
          } else {
            const e=this.edges.find(ed=>(ed.a===a&&ed.b===b)||(ed.a===b&&ed.b===a));
            e.valveOpen = true;
          }
        }
      }
    }

    // some more opens
    const openProb = clamp(0.05 + 0.03*(this.levelNo-1), 0.05, 0.30);
    for (const e of this.edges){
      if (e.isChute) { e.valveOpen = true; continue; }
      if (!e.valveOpen && Math.random() < openProb) e.valveOpen = true;
    }

    // diamonds on plausible routes
    const {forwardNodes, backwardNodes} = this.forwardBackwardSets(nodeById);
    const onSrcSinkPath = (e)=>{
      const A=nodeById.get(e.a), B=nodeById.get(e.b);
      return (forwardNodes.has(e.a) && backwardNodes.has(e.b) && B.y >= A.y - 0.01) ||
             (forwardNodes.has(e.b) && backwardNodes.has(e.a) && A.y >= B.y - 0.01);
    };
    const candidates = this.edges.filter(e=> onSrcSinkPath(e) && !(e.a===this.sourceId || e.b===this.sourceId));
    const count = clamp(Math.round(candidates.length*0.28), 8, 18);
    const picked = new Set();
    while (picked.size < Math.min(count, candidates.length)) picked.add(randInt(0, candidates.length-1));
    [...picked].forEach(i => { candidates[i].hasDiamond = true; });
  }

  relayout(newSpacing){
    if (!newSpacing || newSpacing <= 0) return;
    this.spacing = newSpacing;
    for (const n of this.nodes){
      const {x,y} = this.xy(n.gx, n.gy);
      n.x = x; n.y = y;
    }
    const nodeById = new Map(this.nodes.map(n=>[n.id,n]));
    for (const e of this.edges){
      const A = nodeById.get(e.a), B = nodeById.get(e.b);
      e.len = Math.hypot(B.x - A.x, B.y - A.y);
      e.mid = { x:(A.x+B.x)/2, y:(A.y+B.y)/2 };
      if (e.curve){
        const mx = (A.x+B.x)/2, my = (A.y+B.y)/2;
        const dx = e.curve.cx - mx, dy = e.curve.cy - my;
        const maxOff = this.spacing * 0.16;
        const scale = Math.min(1, maxOff / Math.max(1, Math.hypot(dx,dy)));
        e.curve = { cx: mx + dx*scale, cy: my + dy*scale };
      }
    }
  }

  // Gravity rule: flat or down (no up)
  allowedByGravity(nodeById, aId, bId){
    const A=nodeById.get(aId), B=nodeById.get(bId);
    if (!A || !B) return false;
    return B.y >= A.y - 0.01;
  }

  forwardBackwardSets(nodeById){
    const forwardNodes=new Set([this.sourceId]);
    const q1=[this.sourceId];
    while (q1.length){
      const cur=q1.shift(); const n=nodeById.get(cur);
      for (const eid of n.edges){
        const e=this.edges.find(x=>x.id===eid); if (!e) continue;
        const other=(e.a===cur)?e.b:e.a;
        if (!forwardNodes.has(other) && this.allowedByGravity(nodeById, cur, other)){
          forwardNodes.add(other); q1.push(other);
        }
      }
    }
    const backwardNodes=new Set([this.sinkId]);
    const q2=[this.sinkId];
    while (q2.length){
      const cur=q2.shift(); const n=nodeById.get(cur);
      for (const eid of n.edges){
        const e=this.edges.find(x=>x.id===eid); if (!e) continue;
        const other=(e.a===cur)?e.b:e.a;
        if (!backwardNodes.has(other) && this.allowedByGravity(nodeById, other, cur)){
          backwardNodes.add(other); q2.push(other);
        }
      }
    }
    return {forwardNodes, backwardNodes};
  }
}

/* ============ Renderer ============ */
class Renderer {
  constructor(canvas, level, sim){
    this.c=canvas; this.ctx=canvas.getContext('2d'); this.level=level; this.sim=sim;
    this.dpr=1;
    this.wrap = document.getElementById('stageWrap');

    const safeResize = ()=>this.resize();

    if (window.ResizeObserver) {
      const ro = new ResizeObserver(safeResize);
      ro.observe(this.wrap);
    }
    window.addEventListener('orientationchange', safeResize, {passive:true});
    window.addEventListener('resize', safeResize, {passive:true});
    // Fallback: ensure at least one resize happens after load
    window.setTimeout(safeResize, 0);

    this.resize();
  }
  resize(){
    // Use wrapper rect; fall back to viewport if zero (some webviews)
    let rect = this.wrap.getBoundingClientRect();
    if (rect.height < 1 || rect.width < 1) {
      rect = { width: window.innerWidth, height: window.innerHeight };
    }
    const dpr = Math.min(2, window.devicePixelRatio || 1);
    this.dpr = dpr;
    this.c.width=Math.max(1, Math.floor(rect.width*dpr));
    this.c.height=Math.max(1, Math.floor(rect.height*dpr));
    this.ctx.setTransform(dpr,0,0,dpr,0,0);

    // Fit grid to canvas
    const pad = this.level.pad || 1;
    const neededCols = this.level.cols + pad*2;
    const neededRows = this.level.rows + pad*2;
    const usableW = rect.width * 0.95;
    const usableH = rect.height * 0.95;
    const sX = usableW / neededCols;
    const sY = usableH / neededRows;
    const newSpacing = Math.floor(Math.max(24, Math.min(sX, sY)));
    if (Math.abs(newSpacing - this.level.spacing) > 0.5){
      this.level.relayout(newSpacing);
    }

    this.draw();
  }
  pointAt(a,b,curve,t){
    if (!curve) return {x:a.x+(b.x-a.x)*t, y:a.y+(b.y-a.y)*t};
    const u=1-t, x=u*u*a.x + 2*u*t*curve.cx + t*t*b.x, y=u*u*a.y + 2*u*t*curve.cy + t*t*b.y;
    return {x,y};
  }
  drawPipeBase(a,b,curve,isChute){
    const ctx=this.ctx;
    ctx.save();
    ctx.lineCap='round'; ctx.lineJoin='round';
    ctx.lineWidth=isChute?14:12;
    ctx.strokeStyle=isChute?'#6b86ff':'#5f79d9';
    ctx.globalAlpha=0.95;
    ctx.beginPath(); ctx.moveTo(a.x,a.y);
    if (curve) ctx.quadraticCurveTo(curve.cx,curve.cy,b.x,b.y); else ctx.lineTo(b.x,b.y);
    ctx.stroke(); ctx.restore();
  }
  drawPipeFill(a,b,curve,t,dir,brightness){
    if (t<=0) return;
    const ctx=this.ctx;
    const steps=Math.ceil(28*t);
    const k = clamp(brightness ?? 1, 0, 1);
    const lineW = 6 + 4*k;
    const alpha = 0.35 + 0.65*k;
    const glow  = 4 + 8*k;

    ctx.save(); ctx.lineCap='round'; ctx.lineJoin='round';
    ctx.lineWidth=lineW; ctx.strokeStyle='#3ad0ff'; ctx.shadowColor='#3ad0ff'; ctx.shadowBlur=glow; ctx.globalAlpha=alpha;
    let last=this.pointAt(a,b,curve, dir===+1?0:1);
    for (let i=1;i<=steps;i++){
      const tt=(i/steps)*t, param=dir===+1?tt:(1-tt), p=this.pointAt(a,b,curve,param);
      ctx.beginPath(); ctx.moveTo(last.x,last.y); ctx.lineTo(p.x,p.y); ctx.stroke(); last=p;
    }
    ctx.restore();
  }
  drawValve(mid, open){
    const ctx=this.ctx;
    ctx.save(); ctx.lineWidth=2;
    ctx.fillStyle=open?'#28d17c':'#ff7b66'; ctx.strokeStyle='#0b1020';
    ctx.beginPath(); ctx.arc(mid.x,mid.y,9,0,Math.PI*2); ctx.fill(); ctx.stroke();
    ctx.beginPath();
    if (open){ ctx.moveTo(mid.x-5,mid.y); ctx.lineTo(mid.x+5,mid.y); }
    else { ctx.moveTo(mid.x-4,mid.y-4); ctx.lineTo(mid.x+4,mid.y+4); }
    ctx.strokeStyle='#061022'; ctx.lineWidth=2; ctx.stroke();
    ctx.restore();
  }
  drawDiamondAt(p, taken){
    const ctx=this.ctx, r=7;
    ctx.save();
    ctx.translate(p.x,p.y);
    ctx.rotate(Math.PI/4);
    ctx.fillStyle = taken ? '#9aa2ad' : '#d9dde2';
    ctx.strokeStyle = '#5f6770';
    ctx.lineWidth=2;
    ctx.beginPath(); ctx.rect(-r,-r,2*r,2*r); ctx.fill(); ctx.stroke();
    ctx.restore();
  }
  drawSource(node){
    const ctx=this.ctx;
    ctx.save(); ctx.fillStyle='#94e6ff'; ctx.strokeStyle='#173b68'; ctx.lineWidth=3;
    ctx.beginPath(); ctx.arc(node.x,node.y,12,0,Math.PI*2); ctx.fill(); ctx.stroke(); ctx.restore();
  }
  drawSink(node){
    const ctx=this.ctx;
    ctx.save();
    ctx.strokeStyle='#6be3a3'; ctx.lineWidth=3;
    ctx.beginPath(); ctx.moveTo(node.x-10,node.y+10); ctx.lineTo(node.x+10,node.y+10); ctx.stroke();
    ctx.restore();
  }
  draw(){
    const ctx=this.ctx;
    ctx.clearRect(0,0,this.c.width,this.c.height);
    ctx.save(); ctx.strokeStyle='rgba(255,255,255,0.03)'; ctx.lineWidth=1;
    const {width,height}=this.wrap.getBoundingClientRect();
    const step=40;
    for (let x=0;x<width;x+=step){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,height); ctx.stroke(); }
    for (let y=0;y<height;y+=step){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(width,y); ctx.stroke(); }
    ctx.restore();

    const nodeById=new Map(this.level.nodes.map(n=>[n.id,n]));
    for (const e of this.level.edges.filter(e=>e.isChute)){
      const a=nodeById.get(e.a), b=nodeById.get(e.b);
      this.drawPipeBase(a,b,e.curve,true);
    }
    for (const e of this.level.edges.filter(e=>!e.isChute)){
      const a=nodeById.get(e.a), b=nodeById.get(e.b);
      this.drawPipeBase(a,b,e.curve,false);
    }
    for (const e of this.level.edges){
      const a=nodeById.get(e.a), b=nodeById.get(e.b);
      this.drawPipeFill(a,b,e.curve, e.t, e.dir||+1, e.brightness ?? 1);
    }
    for (const e of this.level.edges){
      if (!e.hasDiamond) continue;
      const a=nodeById.get(e.a), b=nodeById.get(e.b);
      const pos = this.pointAt(a,b,e.curve, e.diamondT);
      this.drawDiamondAt(pos, e.diamondTaken);
    }
    for (const e of this.level.edges){ this.drawValve(e.mid, e.valveOpen); }
    const src=nodeById.get(this.level.sourceId); if (src) this.drawSource(src);
    const sink=nodeById.get(this.level.sinkId); if (sink) this.drawSink(sink);
  }
}

/* ============ Flow (VALVE-FIRST, gravity, idle detector) ============ */
class FlowSim {
  constructor(level){
    this.level=level;
    this.active=[];
    this.running=false;
    this.paused=false;
    this.started=false;
    this.speed=1.2;
    this.collected=0;
    this.sinkReached=false;
    this.lastProgressMs = performance.now();
    this.idleMs = 1000;
  }
  reset(){
    this.active=[]; this.running=false; this.paused=false; this.started=false;
    this.collected=0; this.sinkReached=false;
    this.lastProgressMs = performance.now();
    for (const e of this.level.edges){
      e.filled=false; e.t=0; e.diamondTaken=false; e.dir=+1; e.brightness=0;
    }
    document.getElementById('sinkReached').textContent = 'No';
    hideOverlay();
  }
  spawnFromNode(nodeId, cameFromEdgeId=null, intensity=1){
    const nodeById=new Map(this.level.nodes.map(n=>[n.id,n]));
    const n=nodeById.get(nodeId); if (!n) return;
    const candidates = n.edges
      .map(id=>this.level.edges.find(e=>e.id===id))
      .filter(e=>e && e.id!==cameFromEdgeId)
      .map(e=>{
        const dir = (e.a===n.id) ? +1 : -1;
        const from = n.id;
        const to = (dir===+1) ? e.b : e.a;
        return {e, dir, from, to};
      })
      .filter(({from,to})=> this.level.allowedByGravity(nodeById, from, to));
    if (candidates.length===0) return;
    const share = intensity / candidates.length;
    for (const {e, dir} of candidates){
      const startT = (dir===+1) ? 0 : 1;
      this.active.push({eid:e.id, dir, t:startT, intensity:share, stage:'toValve', fromNode:n.id});
    }
  }
  seed(){
    const nodeById=new Map(this.level.nodes.map(n=>[n.id,n]));
    const src=nodeById.get(this.level.sourceId); if (!src) return;
    this.started=true;
    this.spawnFromNode(src.id, null, 1);
    this.running=this.active.length>0;
    hideOverlay();
  }
  finish(){
    this.running=false;
    document.getElementById('finalScore').textContent = this.collected;
    document.getElementById('finalTotal').textContent = level.edges.filter(e=>e.hasDiamond).length;
    const {edgeSet, diamondCount} = computeRecommendedValveSet(level);
    level.solutionEdgeIds = edgeSet;
    level.solutionDiamonds = diamondCount;
    document.getElementById('solutionSummary').textContent =
      `Recommended network targets ${diamondCount}/${level.edges.filter(e=>e.hasDiamond).length} diamonds.`;
    showOverlay();
  }
  step(dt){
    if (!this.running || this.paused) return;
    const nodeById=new Map(this.level.nodes.map(n=>[n.id,n]));
    const next=[]; let progressed=false;

    for (const front of this.active){
      const e=this.level.edges.find(x=>x.id===front.eid); if (!e) continue;

      if (front.stage==='waiting'){
        e.t=Math.max(e.t, 0.5); e.dir=front.dir;
        e.brightness=Math.max(e.brightness ?? 0, front.intensity ?? 1);
        if (e.valveOpen){ front.stage='toEnd'; progressed=true; }
        next.push(front); continue;
      }

      const target = (front.stage==='toValve') ? 0.5 : 1.0;
      const curParam = (front.dir===+1) ? front.t : (1-front.t);
      const len = e.len || 1;
      const advance = (dt * 1.0 * this.speed) / len;
      const newParam = Math.min(target, curParam + advance);
      if (newParam > curParam + 1e-6) progressed=true;
      front.t = (front.dir===+1) ? newParam : (1 - newParam);

      e.t = Math.max(e.t, Math.abs(newParam));
      e.dir = front.dir;
      e.brightness = Math.max(e.brightness ?? 0, front.intensity ?? 1);

      if (e.hasDiamond && !e.diamondTaken){
        const passParam = (front.dir===+1) ? front.t : (1-front.t);
        let crossed=false;
        if (front.stage==='toValve'){
          crossed = (front.dir===+1)
            ? (e.diamondT <= passParam && e.diamondT >= 0)
            : ((1 - e.diamondT) <= (1 - passParam) && (1 - e.diamondT) >= 0);
        } else {
          crossed = (front.dir===+1)
            ? (e.diamondT <= passParam && e.diamondT >= 0.5)
            : ((1 - e.diamondT) <= (1 - passParam) && (1 - e.diamondT) >= 0.5);
        }
        if (crossed){ e.diamondTaken=true; this.collected++; progressed=true; updateHUD(); }
      }

      const arrived = Math.abs(newParam - target) < 1e-6 || newParam===target;
      if (!arrived){ next.push(front); continue; }

      if (front.stage==='toValve'){
        if (!e.valveOpen){
          front.stage='waiting'; e.t=Math.max(e.t, 0.5); next.push(front);
        } else { front.stage='toEnd'; next.push(front); }
      } else {
        e.filled=true;
        const reachNodeId = (front.dir===+1) ? e.b : e.a;
        if (!this.sinkReached && nodeById.get(reachNodeId)?.isSink){
          this.sinkReached = true; document.getElementById('sinkReached').textContent = 'Yes';
        }
        this.spawnFromNode(reachNodeId, e.id, front.intensity);
        progressed=true;
      }
    }

    this.active=next;
    if (progressed) this.lastProgressMs = performance.now();

    const now = performance.now();
    const allWaitingClosed = this.active.length>0 && this.active.every(fr => {
      if (fr.stage!=='waiting') return false;
      const edge = this.level.edges.find(e=>e.id===fr.eid);
      return edge && !edge.valveOpen;
    });

    if (this.active.length===0){ this.finish(); return; }
    if (allWaitingClosed && (now - this.lastProgressMs) >= this.idleMs){ this.finish(); return; }
  }
}

/* ============ Recommendation (unchanged) ============ */
function buildAdj(level){
  const nodeById = new Map(level.nodes.map(n=>[n.id,n]));
  const out = new Map(level.nodes.map(n=>[n.id, []]));
  const rev = new Map(level.nodes.map(n=>[n.id, []]));
  for (const e of level.edges){
    const A=e.a, B=e.b;
    if (level.allowedByGravity(nodeById, A, B)){
      out.get(A).push({to:B, eid:e.id});
      rev.get(B).push({from:A, eid:e.id});
    }
    if (level.allowedByGravity(nodeById, B, A)){
      out.get(B).push({to:A, eid:e.id});
      rev.get(A).push({from:B, eid:e.id});
    }
  }
  return {out, rev};
}
function bfsFrom(out, start){
  const prev = new Map(); const seen = new Set([start]); const q=[start];
  while(q.length){
    const u=q.shift();
    for (const {to, eid} of out.get(u)){
      if (!seen.has(to)){ seen.add(to); prev.set(to, {prevNode:u, eid}); q.push(to); }
    }
  }
  return {prev, seen};
}
function nextEdgeToSink(rev, sink){
  const next = new Map(); const seen = new Set([sink]); const q=[sink];
  while(q.length){
    const v=q.shift();
    for (const {from, eid} of rev.get(v)){
      if (!seen.has(from)){ seen.add(from); next.set(from, eid); q.push(from); }
    }
  }
  return {next, seen};
}
function reconstructPathEdgesTo(prevMap, target, source){
  const edges=[]; let cur=target;
  while(cur !== source && prevMap.has(cur)){ const {prevNode, eid} = prevMap.get(cur); edges.push(eid); cur = prevNode; }
  edges.reverse(); return (cur===source)? edges : [];
}
function reconstructPathEdgesFrom(nextMap, start){
  const edges=[]; let cur=start; const safety=2000; let steps=0;
  while(nextMap.has(cur) && steps<safety){
    const eid = nextMap.get(cur); edges.push(eid);
    const e = level.edges.find(x=>x.id===eid); if (!e) break;
    const to = (e.a===cur)? e.b : (e.b===cur? e.a : null); if (!to) break; cur = to; steps++;
  }
  return edges;
}
function computeRecommendedValveSet(level){
  const {out, rev} = buildAdj(level);
  const source = level.sourceId, sink = level.sinkId;
  const {prev: prevFromSrc, seen: reachFromSrc} = bfsFrom(out, source);
  const {next: nextTowardSink, seen: reachToSink} = nextEdgeToSink(rev, sink);
  const edgeSet = new Set();
  for (const e of level.edges){ if (e.isChute) edgeSet.add(e.id); }
  for (const e of level.edges.filter(x=>x.hasDiamond)){
    const u = e.a, v = e.b; let added=false;
    if (!added && out.get(u).some(o=>o.to===v) && reachFromSrc.has(u) && reachToSink.has(v)){
      reconstructPathEdgesTo(prevFromSrc, u, source).forEach(id=>edgeSet.add(id));
      edgeSet.add(e.id); reconstructPathEdgesFrom(nextTowardSink, v).forEach(id=>edgeSet.add(id)); added=true;
    }
    if (!added && out.get(v).some(o=>o.to===u) && reachFromSrc.has(v) && reachToSink.has(u)){
      reconstructPathEdgesTo(prevFromSrc, v, source).forEach(id=>edgeSet.add(id));
      edgeSet.add(e.id); reconstructPathEdgesFrom(nextTowardSink, u).forEach(id=>edgeSet.add(id)); added=true;
    }
  }
  const diamondCount = level.edges.reduce((s,e)=> s + ((e.hasDiamond && edgeSet.has(e.id))?1:0), 0);
  return {edgeSet, diamondCount};
}

/* ============ Wire-up ============ */
const canvas=document.getElementById('stage');
const level=new PipeLevel(9, 8, 70);
level.gen(1);
const sim=new FlowSim(level);
const renderer=new Renderer(canvas, level, sim);

const levelNumEl=document.getElementById('levelNum');
const gemScoreEl=document.getElementById('gemScore');
const gemTotalEl=document.getElementById('gemTotal');
const startBtn=document.getElementById('startBtn');
const pauseBtn=document.getElementById('pauseBtn');
const resetBtn=document.getElementById('resetBtn');
const nextBtn=document.getElementById('nextBtn');
const flowRate=document.getElementById('flowRate');
const overlayEl=document.getElementById('overlay');
const overlayRestart=document.getElementById('overlayRestart');
const overlayNext=document.getElementById('overlayNext');
const overlayApplySol=document.getElementById('overlayApplySol');

function updateHUD(){
  const total=level.edges.filter(e=>e.hasDiamond).length;
  gemTotalEl.textContent=total; gemScoreEl.textContent=sim.collected;
}
function showOverlay(){ overlayEl.classList.remove('hidden'); }
function hideOverlay(){ overlayEl.classList.add('hidden'); }
updateHUD();

let last=performance.now();
function tick(t){
  const dt=(t-last)/16.67; last=t;
  sim.step(dt); renderer.draw(); requestAnimationFrame(tick);
}
requestAnimationFrame(tick);

// Controls
startBtn.addEventListener('click', ()=>{
  if (!sim.running && sim.active.length===0) sim.seed();
  sim.paused=false; sim.running=true; hideOverlay();
});
pauseBtn.addEventListener('click', ()=>{ sim.paused=true; sim.running=false; });
resetBtn.addEventListener('click', ()=>{ sim.reset(); updateHUD(); renderer.draw(); });
nextBtn.addEventListener('click', ()=>{
  const n=Number(levelNumEl.textContent||"1")+1; level.gen(n);
  levelNumEl.textContent=n; sim.reset(); updateHUD(); renderer.draw();
});
overlayRestart.addEventListener('click', ()=>{ sim.reset(); updateHUD(); renderer.draw(); hideOverlay(); });
overlayNext.addEventListener('click', ()=>{
  const n=Number(levelNumEl.textContent||"1")+1; level.gen(n);
  levelNumEl.textContent=n; sim.reset(); updateHUD(); renderer.draw(); hideOverlay();
});
overlayApplySol.addEventListener('click', ()=>{
  const {edgeSet, diamondCount} = computeRecommendedValveSet(level);
  level.solutionEdgeIds = edgeSet;
  level.solutionDiamonds = diamondCount;
  for (const e of level.edges){
    e.valveOpen = e.isChute || level.solutionEdgeIds.has(e.id);
    e.filled=false; e.t=0; e.diamondTaken=false; e.brightness=0;
  }
  sim.reset(); updateHUD(); renderer.draw(); hideOverlay();
  sim.seed(); sim.paused=false; sim.running=true;
});

flowRate.addEventListener('input', ()=>{ sim.speed=Number(flowRate.value); });

// Tap valves
function pointerXY(evt){
  const r=canvas.getBoundingClientRect();
  const x=(evt.clientX ?? evt.touches?.[0]?.clientX)-r.left;
  const y=(evt.clientY ?? evt.touches?.[0]?.clientY)-r.top;
  return {x,y};
}
function hitValve(level,x,y){
  const r=12; let hit=null, best=r*r;
  for (const e of level.edges){ const dx=x-e.mid.x, dy=y-e.mid.y, d2=dx*dx+dy*dy; if (d2<best){ best=d2; hit=e; } }
  return hit;
}
const toggleValve=(evt)=>{
  evt.preventDefault();
  const {x,y}=pointerXY(evt); const e=hitValve(level,x,y);
  if (e){ e.valveOpen=!e.valveOpen; }
};
canvas.addEventListener('click', toggleValve);
canvas.addEventListener('touchstart', toggleValve, {passive:false});

// Start paused
sim.reset(); renderer.draw();
</script>
</body>
</html>
